#!/bin/bash
# kak remote control, reimplementation of alexherbo2's connect.kak

function -kak-escape() {
  # From https://github.com/alexherbo2/prelude.kak/blob/master/rc/prelude.sh
  # Original implementation by Screwtape https://github.com/mawww/kakoune/issues/3340
  for text do
    printf "'"
    while true; do
      case "$text" in
        *"'"*)
          head=${text%%"'"*}
          tail=${text#*"'"}
          printf "%s''" "$head"
          text=$tail
          ;;
        *)
          printf "%s' " "$text"
          break
          ;;
      esac
    done
  done
  printf "\n"
}

function -ensure-env {
    # Exit program if $session is not set.
    if [[ -z $session ]]; then
        echo 'kak $session not set' >&2
        exit
    fi
}

function kak-defs {
    # Run in kak with `eval %sh{ krc kak-defs }` to define :connect.
    self=$(realpath $0)
    echo '
        def connect -override -params 1.. %{
            %arg{1} bash -c %{
                export session=$1
                export client=$2
                cd $3
                shift 4
                [ "$1" ] && "$@" || "$SHELL"
            } -- %val{session} %val{client} %sh{pwd} %arg{@}
        }

        def shell -params 1.. -override %{
            nop %sh{
                setsid "$@" < /dev/null > /dev/null 2>&1 &
            }
        }

        def connect-shell -params 1.. -override %{
            connect shell %arg{@}
        }

        def connect-terminal -params .. -override %{
            connect terminal %arg{@}
        }
    '
}

function env {
    # Print the current $session and $client to stdout.
    echo session: "$session"
    echo client: "$client"
}


function raw-send {
    # Evaluate kak script from stdin in $session. Run in $client if set.
    -ensure-env
    d=$(mktemp --suffix=-krc-send)
    cat > "$d"
    if [[ -n $client ]]; then
        echo "eval -try-client $client %{ source $d; nop %sh{ rm $d } }" | kak -p "$session"
    else
        echo "source $d; nop %sh{ rm $d }" | kak -p "$session"
    fi
}

function send {
    # Run one kak command in $session, in $client if set.
    -kak-escape "$@" | raw-send
}

function send-fg {
    # Run one kak command in $session, in $client if set. Focus the client afterwards.
    { -kak-escape "$@"; echo focus; } | raw-send
}

function get {
    # Print the echo of arguments in kak $session on stdout. Run in $client if set.
    d=$(mktemp -d --suffix=-krc-get)
    out="$d/out"
    err="$d/err"
    touch "$out"
    touch "$err"
    fifo="$d/fifo"
    mkfifo "$fifo"
    trap "rm -rf $d" EXIT
    echo "
         try %{
             echo -to-file $out "$@"
         } catch %{
             echo -to-file $err %val{error}
         }
         echo -to-file $fifo done
    " | raw-send
    cat "$fifo" >/dev/null
    cat "$out"
    cat "$err" >&2
}

function attach {
    # Start a new kak client in $session.
    -ensure-env
    kak -c "$session" "$@"
}

function attach-with {
    # Start a new kak client in $session, running the argument kak command at startup.
    -ensure-env
    d=$(mktemp --suffix=-krc-attach-with)
    -kak-escape "$@" > "$d"
    kak -c "$session" -e "source $d; nop %sh{ rm $d }"
}

function fifo {
    # Send output of argument command, or read stdin, to a fifo buffer.
    -ensure-env
    d=$(mktemp -d --suffix=-krc-fifo)
    fifo="$d/fifo"
    mkfifo "$fifo"
    trap "rm -rf $d" EXIT
    send edit! -fifo "$fifo" '*fifo*'
    if [[ $# > 0 ]]; then
        "$@" > "$fifo" 2>&1 &
    elif [[ ! -t 0 ]]; then
        cat > "$fifo"
    fi
}

if [[ $(type -t $1) == 'function' ]]; then
    f=$1
    shift
    "$f" "$@"
else
    printf 'kakoune-remote-control (krc)\n'

    printf 'Usage:\n    %s COMMAND [...ARGS]\n' $(basename "$0")
    printf '\n'
    printf 'Where COMMAND is one of:\n'

    self=$(realpath $0)
    functions=$(grep -Po '^function \K[:\w][\w-]+' "$self")
    if [[ -z "$cols" ]]; then
        cols=$(tput cols)
    fi
    for fn in $functions; do
        paste <(printf '  %-12s' "$fn") <(
            cat "$self" |
            sed -n "/^function $fn /,/^}/p" | sed -n 's/^\s\+\#\s\+//p' |
            fmt -w $(($cols - 15))
        ) | column -s $'\t' -t
    done
fi
